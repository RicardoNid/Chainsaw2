package org.datenlord
package flowConverters

import breeze.linalg._
import flowConverters.Permutation
import spinal.core._
import spinal.lib._

import scala.collection.{immutable, mutable}
import scala.collection.mutable.ArrayBuffer
import scala.language.postfixOps


/** Stream permutation module for arbitrary permutation, based on RAMs
 *
 * @param permutation permutation defined by a sequence of integers, can be generated by Random.shuffle on (0 until n) sequence
 * @param bitWidth    bit width of elements in input & output vector
 * @see ''Automatic Generation of Streaming Datapaths for Arbitrary Fixed Permutations, Peter A. Milder, James C. Hoe, and Markus PÂ¨uschel''
 */
case class PermutationByRamAnother(permutation: Permutation, streamWidth: Int, bitWidth: Int)
  extends ChainsawGenerator {

  val N = permutation.size
  require(N % streamWidth == 0 && N > streamWidth)

  override def name = s"permutationByRam_N${permutation.size}_sw${streamWidth}_w${bitWidth}_${permutation.hashCode()}".replace("-", "N")

  override val impl = (dataIn: Seq[Any]) => permutation.permute(dataIn.asInstanceOf[Seq[BigInt]])

  override var inputTypes = Seq.fill(streamWidth)(UIntInfo(bitWidth))
  override var outputTypes = Seq.fill(streamWidth)(UIntInfo(bitWidth))

  override var inputFormat = MatrixFormat(streamWidth, N / streamWidth)
  override var outputFormat = MatrixFormat(streamWidth, N / streamWidth)

  /** --------
   * algorithms for construction
   * -------- */

  /** decompose the mapping matrix into a sum of N/streamWidth permutations matrices
   *
   * @return a sequence of permutation matrices
   */
  def getDecomposition(mapping: DenseMatrix[Int]): Seq[Permutation] = {
    val n = mapping.rows
    logger.info(s"start decomposing mapping matrix of size $n X $n: \n${mapping.toString()}")
    // brute force(traversal) algorithm
    val ret = ArrayBuffer[Permutation]() // permutation matrices
    var current = mapping
    val perms = (0 until n).permutations // generate all permutations of length n, implemented as a iterator(delayed)
    perms.foreach { perm =>
      val permMatrix = Permutation(perm).getPermutationMatrix
      // algorithm 6 line 3-6
      // TODO: implement this algorithm based on a SAT solver
      while ((current - permMatrix).forall(_ >= 0)) {
        current = current - permMatrix
        ret += Permutation(perm)
      }
    }
    ret
  }

  /** get control bits stored in R,W & T by decomposing mapping matrix
   *
   * @return (permutations of switch network, readAddr for RAM0, writeAddr for RAM1)
   */
  def getControls(permutations: Seq[Permutation]): (Seq[Permutation], ArrayBuffer[Seq[Int]], ArrayBuffer[Seq[Int]]) = {
    logger.info(s"start building control/address from the decomposition")
    val readAddrs = ArrayBuffer[Seq[Int]]() // read addr of M_0
    val writeAddrs = ArrayBuffer[Seq[Int]]() // write addr of M_1
    // remained elements
    val elems = mutable.Set(0 until N: _*)
    // decomposition of mapping matrix
    permutations.foreach { perm =>
      // algorithm 6 line7
      val elem = (0 until streamWidth).map { i =>
        elems.find(x => (x % streamWidth == i) && (permutation.permuted.indexOf(x) % streamWidth == perm.permuted.indexOf(i))).get
      }
      elems --= elem
      readAddrs += elem.map(_ / streamWidth) // algorithm 6 line9
      writeAddrs += elem.indices.map(index => permutation.permuted.indexOf(elem(perm.permuted(index))) / streamWidth) // algorithm 6 line10
    }
    (permutations, readAddrs, writeAddrs)
  }

  val mappingMatrix = permutation.getMappingMatrix(streamWidth)
  val decomposition = getDecomposition(mappingMatrix)
  val (subPermutations, readAddr, writeAddr) = getControls(decomposition)
  val benesNetwork = BenesNetworkAnother(streamWidth, subPermutations, bitWidth, 1)

  override var latency = period * 2 + benesNetwork.latency

  /** --------
   * implementation
   * -------- */
  override def implH: ChainsawModule = new ChainsawModule(this) {
    val memDepth = 2 * period
    val addrWidth = log2Up(period)

    /** --------
     * components
     -------- */
    val network = benesNetwork.implDut // switch network
    // ROMs
    val R = Mem(readAddr.map(seq => Vec(seq.map(U(_, addrWidth bits)))))
    val W = Mem(writeAddr.map(seq => Vec(seq.map(U(_, addrWidth bits)))))
    val M0, M1 = Seq.fill(streamWidth)(Mem(Bits(bitWidth bits), memDepth))
    val pingPongM0, pingPongM1 = RegInit(False)

    /** --------
     * controls
     -------- */
    val time = localCounter.value
    val timeForM1 = time.d(benesNetwork.latency)

    val lastForM0 = lastIn
    val lastForBenes = lastIn.validAfter(period)
    val lastForM1 = lastForBenes.validAfter(period + benesNetwork.latency)

    pingPongM0.toggleWhen(lastForM0)
    pingPongM1.toggleWhen(lastForM1)

    /** --------
     * data path
     -------- */
    // step 1 input -> M0
    M0.zip(dataIn).foreach { case (port, data) => port.write(time @@ pingPongM0, data) }
    // step 2 M0 -> data
    val readAddrs = R.readAsync(time)
    val afterM0 = M0.zip(readAddrs).map { case (port, addr) => port.readAsync(addr @@ ~pingPongM0) }
    // step 3 data -> network -> data
    network.dataIn.fragment := afterM0
    network.dataIn.last := lastForBenes
    network.dataIn.valid.assignDontCare()
    val afterBenes = network.dataOut.fragment
    // step 4 data -> M1
    val writeAddrs = W.readAsync(timeForM1)
    M1.zip(writeAddrs.zip(afterBenes)).foreach { case (port, (addr, data)) => port.write(addr @@ pingPongM1, data) }
    // step 5 M1 -> output
    dataOut := M1.map(port => port.readAsync(timeForM1 @@ ~pingPongM1))

  }
}