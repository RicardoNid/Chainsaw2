package org.datenlord
package arithmetic

import breeze.linalg.linspace
import org.datenlord.xilinx.VivadoReport
import org.scalatest.flatspec.AnyFlatSpec

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer
import scala.util.Random
import java.io._

class BitHeapCompressorTest extends AnyFlatSpec {

  val defaultReportPath = "./BitHeapPerfReport"

  Random.setSeed(2000)

  sealed trait Strategy

  object Increase extends Strategy

  object Decrease extends Strategy

  object Randomly extends Strategy

  object NoneStrategy extends Strategy

  def genNoise(bound: Int): Int = Random.nextInt(2 * bound + 1) - bound // -8~8

  def genRectangularInfos(width: Int, height: Int, shift: Int = 0, sign: Boolean = true, withNoise: Boolean = false, timeStrategy: Strategy = NoneStrategy, upBound: Int = 0): Seq[ArithInfo] = {
    def randomShift = if (withNoise) Random.nextInt(width) else 0

    val delta = if (height != 1) upBound / (height - 1) else upBound
    Seq.tabulate(height) { i =>
      val noise = randomShift
      timeStrategy match {
        case NoneStrategy => ArithInfo(width - noise, shift + noise, sign)
        case Increase => ArithInfo(width - noise, shift + noise, sign, i * delta)
        case Decrease => ArithInfo(width - noise, shift + noise, sign, (height - i) * delta)
        case Randomly => ArithInfo(width - noise, shift + noise, sign, Random.nextInt(upBound + 1))
      }
    }
  }

  // input bits formed a "triangle", typically generated by a multiplier
  def genTriangleInfos(width: Int, stairShape: (Int, Int) = (1, 1), withNoise: Boolean = false, truncate: Range = null, sign: Boolean = true, timeStrategy: Strategy = NoneStrategy, upBound: Int = 0): Seq[ArithInfo] = {
    require((width / stairShape._1) % 2 == 1, s"the width / stairShape._1 must be odd number ! your input width is $width\t stairShape._1 is ${stairShape._1}")
    if (truncate != null) {
      require(truncate.head >= 0 && truncate.last <= width - 1, s"the truncate range is out of width! your truncate start : ${truncate.head}  end : ${truncate.last}")
    }
    val delta = if (width / stairShape._1 != 1) upBound / (width / stairShape._1 - 1) else upBound
    val infos = (0 until width / stairShape._1).flatMap { i =>
      val mid = ((width / stairShape._1) + 1) / 2
      val shift = (if (withNoise && i > 0) genNoise(stairShape._1 / 5) else if (withNoise && i == 0) genNoise(stairShape._1 / 5).abs else 0) + i * stairShape._1
      val number = mid - (i - mid + 1).abs
      timeStrategy match {
        case NoneStrategy => Seq.fill(number * stairShape._2)(ArithInfo((if (withNoise) genNoise(stairShape._1 / 5) else 0) + stairShape._1, shift, sign))
        case Increase => Seq.fill(number * stairShape._2)(ArithInfo((if (withNoise) genNoise(stairShape._1 / 5) else 0) + stairShape._1, shift, sign, i * delta))
        case Decrease => Seq.fill(number * stairShape._2)(ArithInfo((if (withNoise) genNoise(stairShape._1 / 5) else 0) + stairShape._1, shift, sign, (width / stairShape._1 - i) * delta))
        case Randomly => Seq.fill(number * stairShape._2)(ArithInfo((if (withNoise) genNoise(stairShape._1 / 5) else 0) + stairShape._1, shift, sign, Random.nextInt(upBound + 1)))
      }
    }

    if (truncate != null) infos.filter(arith => arith.high >= truncate.head && arith.low <= truncate.last).map { arith =>
      var newLow = arith.low
      var newHigh = arith.high
      if (arith.low < truncate.head) newLow = truncate.head
      if (arith.high > truncate.last) newHigh = truncate.last
      ArithInfo(newHigh - newLow + 1, newLow, arith.isPositive, arith.time)
    }
    else infos
  }

  val infosSmall = genRectangularInfos(width = 10, height = 10)

  val infosSmallWithNoise = genTriangleInfos(width = 10, stairShape = (2, 2))

  // input bits formed a rectangular
  val infosRegular = genRectangularInfos(width = 40, height = 40)

  val infosRegularWithNoise = genRectangularInfos(width = 40, height = 40, withNoise = true)

  // input bits formed a "pyramid", typically generated by a multiplier
  val infosFromMult = genTriangleInfos(width = 680, stairShape = (40, 6))

  // input bits formed a truncated "pyramid", typically generated by a truncated multiplier
  val infosFromMultWithTruncated = genTriangleInfos(width = 101, stairShape = (1, 1), truncate = 5 to 80)

  // a "pyramid" with noise of shift and width, typically generated by a Karatsuba multiplier
  val infosFromMultWithNoise = genTriangleInfos(width = 680, stairShape = (40, 6), withNoise = true, timeStrategy = NoneStrategy, upBound = 10)

  val infosWithNegative = genRectangularInfos(width = 10, height = 10, shift = 0, sign = true) ++ genRectangularInfos(width = 5, height = 5, shift = 5, sign = false)

  abstract class InfosShape {
    def getConfig: Seq[(String, Any)]
  }

  case class Rectangle(width: Int, height: Int, shift: Int, sign: Boolean, withNoise: Boolean, mixSign: Boolean, timeStrategy: Strategy, upBound: Int) extends InfosShape {
    override def toString = s"Rectangular : width->$width height->$height shift->$shift sign->$sign withNoise->$withNoise mixSign->$mixSign timeStrategy->${timeStrategy.getClass.getSimpleName.init} upBound->$upBound"

    override def getConfig = Seq(("width", width), ("height", height), ("shift", shift), ("sign", sign), ("withNoise", withNoise), ("mixSign", mixSign))
  }

  case class Triangle(width: Int, stairShape: (Int, Int), sign: Boolean, mixSign: Boolean, withNoise: Boolean, truncate: Range, timeStrategy: Strategy, upBound: Int) extends InfosShape {
    override def toString = s"Triangle : width->$width stairShape->$stairShape sign->$sign mixSign->$mixSign withNoise->$withNoise truncate->${if (truncate == null) "All" else s"${truncate.head} to ${truncate.last}"} timeStrategy->${timeStrategy.getClass.getSimpleName.init} upBound->$upBound"

    override def getConfig = Seq(("width", width), ("stairRowShape", stairShape._1), ("stairColShape", stairShape._2), ("withNoise", withNoise), ("truncate", truncate))
  }

  object RectangularInfos {
    def apply(widthRange: Range = Range.inclusive(5, 20, 5), heightRange: Range = Range.inclusive(5, 20, 5), shift: Int = 0, sign: Boolean = true, withNoise: Boolean = false, mixSign: Boolean = false, timeStrategy: Strategy = NoneStrategy, upBound: Int = 0): Seq[(Seq[ArithInfo], InfosShape)] =
      widthRange.flatMap { w =>
        heightRange.map { h =>
          (
            genRectangularInfos(w, h - (if (mixSign) h / 3 else 0), shift, sign, withNoise, timeStrategy, upBound) ++ genRectangularInfos(w, (if (mixSign) h / 3 else 0), shift, !sign, withNoise, timeStrategy, upBound),
            Rectangle(width = w, height = h, shift = shift, sign = sign, withNoise = withNoise, mixSign = mixSign, timeStrategy = timeStrategy, upBound = upBound)
          )
        }
      }
  }

  object TriangleInfos {
    def apply(
               widthRange: Range = Range.inclusive(15, 21, 6),
               stairRowShapeRange: Range = Range.inclusive(1, 5, 2),
               stairColShapeRange: Range = Range.inclusive(1, 5, 2),
               withNoise: Boolean = false,
               truncate: Range = null,
               sign: Boolean = true,
               mixSign: Boolean = false,
               timeStrategy: Strategy = NoneStrategy,
               upBound: Int = 0
             ): Seq[(Seq[ArithInfo], InfosShape)] = widthRange.flatMap { w =>
      stairRowShapeRange.flatMap { r =>
        stairColShapeRange.map { c =>
          (
            genTriangleInfos(w * r, (r, c), withNoise, truncate, sign, timeStrategy = timeStrategy, upBound = upBound) ++ (if (mixSign) genTriangleInfos(w * r, (r, c), withNoise, truncate, !sign, timeStrategy = timeStrategy, upBound = upBound) else Seq[ArithInfo]()),
            Triangle(w, (r, c), sign, mixSign, withNoise, truncate, timeStrategy, upBound)
          )
        }
      }
    }
  }

  val ALLINFOS = Seq(
    RectangularInfos(widthRange = Range.inclusive(100, 200, 100), heightRange = Range.inclusive(10, 100, 20), timeStrategy = Randomly, upBound = 8),
    RectangularInfos(
      widthRange = Range.inclusive(100, 200, 100),
      heightRange = Range.inclusive(10, 100, 20),
      shift = Random.nextInt(2) + 1,
      withNoise = true,
      timeStrategy = Randomly,
      upBound = 8
    ),
    RectangularInfos(
      widthRange = Range.inclusive(100, 200, 100),
      heightRange = Range.inclusive(10, 100, 20),
      shift = Random.nextInt(2) + 1,
      withNoise = true,
      mixSign = true,
      timeStrategy = Randomly,
      upBound = 8
    ),
    RectangularInfos(widthRange = Range.inclusive(100, 200, 100), heightRange = Range.inclusive(10, 100, 20)),
    RectangularInfos(widthRange = Range.inclusive(100, 200, 100), heightRange = Range.inclusive(10, 100, 20), shift = Random.nextInt(2) + 1, withNoise = true),
    RectangularInfos(widthRange = Range.inclusive(100, 200, 100), heightRange = Range.inclusive(10, 100, 20), shift = 2, withNoise = true, mixSign = true),
    TriangleInfos(widthRange = Range.inclusive(99, 199, 10)),
    TriangleInfos(
      widthRange = Range.inclusive(99, 199, 10),
      stairRowShapeRange = Range.inclusive(1, 5),
      stairColShapeRange = Range.inclusive(1, 5),
      truncate = Range.inclusive(50, 98)
    ),
    TriangleInfos(
      widthRange = Range.inclusive(99, 199, 10),
      stairRowShapeRange = Range.inclusive(2, 5),
      stairColShapeRange = Range.inclusive(2, 5),
      truncate = Range.inclusive(90, 197),
      mixSign = true
    ),
    TriangleInfos(
      widthRange = Range.inclusive(99, 199, 10),
      stairRowShapeRange = Range.inclusive(3, 5),
      stairColShapeRange = Range.inclusive(3, 5),
      truncate = Range.inclusive(180, 296)
    ),
    TriangleInfos(
      widthRange = Range.inclusive(11, 21, 2),
      stairRowShapeRange = Range.inclusive(1, 5),
      stairColShapeRange = Range.inclusive(1, 5),
      truncate = Range.inclusive(5, 10),
      withNoise = true,
      mixSign = true
    ),
    TriangleInfos(timeStrategy = Randomly, upBound = 10),
    TriangleInfos(
      widthRange = Range.inclusive(11, 21, 2),
      stairRowShapeRange = Range.inclusive(1, 5),
      stairColShapeRange = Range.inclusive(1, 5),
      truncate = Range.inclusive(5, 10),
      timeStrategy = Increase,
      upBound = 10
    ),
    TriangleInfos(
      widthRange = Range.inclusive(11, 21, 2),
      stairRowShapeRange = Range.inclusive(2, 5),
      stairColShapeRange = Range.inclusive(2, 5),
      truncate = Range.inclusive(10, 20),
      timeStrategy = Decrease,
      upBound = 10
    ),
    TriangleInfos(
      widthRange = Range.inclusive(11, 21, 2),
      stairRowShapeRange = Range.inclusive(3, 5),
      stairColShapeRange = Range.inclusive(3, 5),
      truncate = Range.inclusive(20, 30),
      mixSign = true,
      timeStrategy = Randomly,
      upBound = 10
    ),
    TriangleInfos(
      widthRange = Range.inclusive(11, 21, 2),
      stairRowShapeRange = Range.inclusive(3, 5),
      stairColShapeRange = Range.inclusive(3, 5),
      truncate = Range.inclusive(5, 10),
      withNoise = true,
      timeStrategy = Randomly,
      upBound = 10
    )
  )

  case class BitHeapCompressorPerfReportGraph(target: TestTarget, reportPath: String = defaultReportPath) {
    val lutData: mutable.Set[(InfosShape, Int)] = mutable.Set[(InfosShape, Int)]()
    val ffData: mutable.Set[(InfosShape, Int)] = mutable.Set[(InfosShape, Int)]()
    val dspData: mutable.Set[(InfosShape, Int)] = mutable.Set[(InfosShape, Int)]()
    val bramData: mutable.Set[(InfosShape, Int)] = mutable.Set[(InfosShape, Int)]()
    val carry8Data: mutable.Set[(InfosShape, Int)] = mutable.Set[(InfosShape, Int)]()
    val fMaxData: mutable.Set[(InfosShape, Double)] = mutable.Set[(InfosShape, Double)]()

    private def removeFromSeq[A <: Any](seq: Seq[A], index: Int) = {
      val ret = seq.toBuffer
      ret.remove(index)
      ret
    }

    def addPerfData(infoShape: InfosShape, vivadoReport: VivadoReport) = {
      lutData += Tuple2(infoShape, vivadoReport.LUT)
      ffData += Tuple2(infoShape, vivadoReport.FF)
      dspData += Tuple2(infoShape, vivadoReport.DSP)
      bramData += Tuple2(infoShape, vivadoReport.BRAM)
      carry8Data += Tuple2(infoShape, vivadoReport.CARRY8)
      fMaxData += Tuple2(infoShape, vivadoReport.Frequency / 1e6)
    }

    private def getGraphData[V <: AnyVal](rowData: mutable.Set[(InfosShape, V)], resourceType: String) = {
      val differentShapeInfos = rowData
        .map(_._1.getClass)
        .map { dShape => rowData.filter { case (shape, _) => shape.getClass == dShape } }
        .map { dShape => dShape.map { case (shape, value) => (shape.getClass.getSimpleName, shape.getConfig, value) } }

      val configLengths = differentShapeInfos.toSeq.map { dShape => dShape.head._2.length }

      val formatData = configLengths
        .zip(differentShapeInfos)
        .map { case (length, shapeInfo) =>
          Seq.tabulate(length) { l =>
            shapeInfo
              .map { info => removeFromSeq(info._2, l) }
              .map { s => (shapeInfo.filter { i => removeFromSeq(i._2, l) == s }, l) }
          }
        }
        .flatMap(dShape => dShape.map(graphSet => graphSet.filter { case (gData, v) => gData.forall { case (_, config, _) => config(v)._2.isInstanceOf[Int] } }).filter(_.nonEmpty))
        .flatten
      val graphData = formatData.map { case (infos, i) =>
        val shapeName = infos.head._1
        val constantParaStr = s"Constant parameter: ${removeFromSeq(infos.head._2, i).map { case (str, value) => s"$str=$value" }.mkString(";")}"
        val xAxisName = infos.head._2(i)._1
        val yAxisName = resourceType
        val xAxisData = ArrayBuffer[Any]()
        val yAxisData = ArrayBuffer[Any]()
        infos.foreach { info =>
          xAxisData += info._2(i)._2
          yAxisData += info._3
        }
        (shapeName, constantParaStr, (xAxisName, xAxisData), (yAxisName, yAxisData))
      }
      graphData
    }

    private def drawGraph(graphData: Seq[(String, String, (String, ArrayBuffer[Any]), (String, ArrayBuffer[Any]))], showNow: Boolean) = {
      graphData.foreach { graph =>
        val (xLabel, xData) = graph._3
        val (yLabel, yData) = graph._4
        val title = s"The graph of $yLabel versus $xLabel on ${graph._1} shape using ${target.getClass.getSimpleName.init}"
        val file = new File(s"$reportPath/$yLabel/")
        file.mkdirs()

        val sortedXData = ArrayBuffer[Double]()
        val sortedYData = ArrayBuffer[Double]()

        println(s"before : \n ${xData.mkString(",")} \n ${yData.mkString(",")}")
        xData.zip(yData).sortBy(_._1.toString.toDouble).foreach { case (x, y) =>
          sortedXData += x.toString.toDouble
          sortedYData += y.toString.toDouble
        }
        println(s"after : \n ${sortedXData.toArray.mkString(",")} \n ${sortedYData.toArray.mkString(",")}")

        matlabEngine.putVariable("x", sortedXData.toArray)
        matlabEngine.putVariable("y", sortedYData.toArray)
        matlabEngine.eval(s"figure('visible', '${if (showNow) "on" else "off"}')")
        matlabEngine.eval("plot(x, y, '-c.', 'LineWidth', 1.5, 'MarkerSize', 15)")
        matlabEngine.eval(s"title('$title')")
        matlabEngine.eval(s"xlabel('$xLabel')")
        matlabEngine.eval(s"ylabel('$yLabel')")
        matlabEngine.eval(s"legend('${graph._2}', 'location', 'SouthOutside')")
        matlabEngine.eval(s"saveas(gcf,'$reportPath/$yLabel/$title.png', 'png')")
      }
    }

    def genPerfGraph(showNow: Boolean = false) = {
      val lutGraphData = getGraphData(lutData, resourceType = "LUT")
      val ffGraphData = getGraphData(ffData, resourceType = "FF")
      val dspGraphData = getGraphData(dspData, resourceType = "DSP")
      val bramGraphData = getGraphData(bramData, resourceType = "BRAM")
      val carry8GraphData = getGraphData(carry8Data, resourceType = "CARRY8")
      val fMaxGraphData = getGraphData(fMaxData, resourceType = "FMAX")

      drawGraph(lutGraphData, showNow)
      drawGraph(ffGraphData, showNow)
      drawGraph(dspGraphData, showNow)
      drawGraph(bramGraphData, showNow)
      drawGraph(carry8GraphData, showNow)
      drawGraph(fMaxGraphData, showNow)

    }
  }

  sealed trait TestTarget

  object UseInversion extends TestTarget

  object UseInversionWithSignFlag extends TestTarget

  object MultiOperand extends TestTarget

  object MultiOperandWithSignFlag extends TestTarget

  def testFuncForInfosOnce(infos: Seq[ArithInfo], target: TestTarget = MultiOperand, testCount: Int = 1000) = {
    //    val data = (0 until testCount) flatMap (_ => infos.map(info => Random.nextBigInt(info.width)))
    target match {
      case UseInversion =>
        val config = BitHeapCompressorUseInversionConfig(infos)
      //        TransformTest.test(config.implH, data)
      case UseInversionWithSignFlag =>
        val config = BitHeapCompressorUseInversionWithSignFlagConfig(infos)
      //        TransformTest.testWithSignFlag(config.implH, data, infos.map(_.time))
      case MultiOperand =>
        val config = MultiOperandAdderConfig(infos)
      //        TransformTest.test(config.implH, data)
      case MultiOperandWithSignFlag =>
        val config = MultiOperandAdderWithSignFlagConfig(infos)
      //        TransformTest.testWithSignFlag(config.implH, data, infos.map(_.time))
    }
  }

  def testPerfForInfosOnce(infos: Seq[ArithInfo], target: TestTarget = MultiOperand): VivadoReport = {
    target match {
      case UseInversion =>
        val config = BitHeapCompressorUseInversionConfig(infos)
        val implReport = VivadoImpl(config.implH, target.getClass.getSimpleName.init)
        implReport.require(config.utilRequirement, config.fMaxRequirement)
        implReport
      case UseInversionWithSignFlag =>
        val config = BitHeapCompressorUseInversionWithSignFlagConfig(infos)
        val implReport = VivadoImpl(config.implH, target.getClass.getSimpleName.init)
        implReport.require(config.utilRequirement, config.fMaxRequirement)
        implReport
      case MultiOperand =>
        val config = MultiOperandAdderConfig(infos)
        val implReport = VivadoImpl(config.implH, target.getClass.getSimpleName.init)
        implReport.require(config.utilRequirement, config.fMaxRequirement)
        implReport
      case MultiOperandWithSignFlag =>
        val config = MultiOperandAdderWithSignFlagConfig(infos)
        val implReport = VivadoImpl(config.implH, target.getClass.getSimpleName.init)
        implReport.require(config.utilRequirement, config.fMaxRequirement)
        implReport
    }
  }

  def bitHeapCompressorFuncTest(target: TestTarget, testCount: Int = 1000) = {
    behavior of s"BitHeap Compressor functional test for ${target.getClass.getSimpleName.init}"
    ALLINFOS.flatten.foreach { case (infos, name) =>
      it should s"work correctly on $name" in testFuncForInfosOnce(infos, target, testCount)
    }
  }

  def bitHeapCompressorPerfTest(target: TestTarget, genPerfReportGraph: Boolean = true, reportGraphPath: String = defaultReportPath) = {
    val perfReportGraph = BitHeapCompressorPerfReportGraph(target, reportGraphPath)
    behavior of s"BitHeap Compressor performance test for ${target.getClass.getSimpleName.init}"
    ALLINFOS.flatten.foreach { case (infos, shape) =>
      val implReport = testPerfForInfosOnce(infos, target)
      it should s"impl successfully on $shape" in implReport
      if (genPerfReportGraph) perfReportGraph.addPerfData(shape, implReport)
    }
    if (genPerfReportGraph) perfReportGraph.genPerfGraph()
  }

  var ignoreTest = true
  if (!ignoreTest) {
    bitHeapCompressorFuncTest(MultiOperandWithSignFlag)
    bitHeapCompressorPerfTest(MultiOperandWithSignFlag)
  }

  //  behavior of "Bit Matrix Compressor on BitHeapCompressorUseInversion"
  //
  //  it should "work on small rectangular shape situation" in testFuncForInfosOnce(infosSmall, UseInversion)
  //  it should "impl for a small rectangular shape situation" in VivadoImpl(BitHeapCompressorUseInversionConfig(genRectangularInfos(10, 10)).implH, "SmallTree")
  //
  //  it should "work on simple situation with noise" in testFuncForInfosOnce(infosSmallWithNoise, UseInversion)
  //  ignore should "impl for simple situation with noise" in testForInfosOnce(infosSmallWithNoise, UseInversion)
  //
  //  it should "work on rectangular shape situation" in testFuncForInfosOnce(genRectangularInfos(40, 40), UseInversion)
  //  it should "work for situation 1" in testFuncForInfosOnce(infosFromMult, UseInversion)
  //  it should "work for situation 2" in testFuncForInfosOnce(infosFromMultWithNoise, UseInversion)
  //
  //  ignore should "impl for rectangular bits" in VivadoImpl(BitHeapCompressorUseInversionConfig(infosRegular).implH, "RegularSum")
  //  ignore should "impl for output from a multiplier" in VivadoImpl(BitHeapCompressorUseInversionConfig(infosFromMult).implH, "PostSum")
  //  ignore should "impl for irregular output from a multiplier" in VivadoImpl(BitHeapCompressorUseInversionConfig(infosFromMultWithNoise).implH, "PostSumIrregular")
  //
  //  it should "work for negative operands" in testFuncForInfosOnce(infosWithNegative, UseInversion)
  //
  //  behavior of "Bit Matrix Compressor on BitHeapCompressorUseInversionWithSignFlag"
  //
  //  it should "work on small rectangular shape situation" in testFuncForInfosOnce(infosSmall, UseInversionWithSignFlag)
  //  it should "impl for a small rectangular shape situation" in VivadoImpl(BitHeapCompressorUseInversionConfig(genRectangularInfos(10, 10)).implH, "SmallTree")
  //
  //  it should "work on simple situation with noise" in testFuncForInfosOnce(infosSmallWithNoise, UseInversionWithSignFlag)
  //  ignore should "impl for simple situation with noise" in testForInfosOnce(infosSmallWithNoise, UseInversionWithSignFlag)
  //
  //  it should "work on rectangular shape situation" in testFuncForInfosOnce(genRectangularInfos(40, 40), UseInversionWithSignFlag)
  //  it should "work for situation 1" in testFuncForInfosOnce(infosFromMult, UseInversionWithSignFlag)
  //  it should "work for situation 2" in testFuncForInfosOnce(infosFromMultWithNoise, UseInversionWithSignFlag)
  //
  //  ignore should "impl for rectangular bits" in VivadoImpl(BitHeapCompressorUseInversionConfig(infosRegular).implH, "RegularSum")
  //  ignore should "impl for output from a multiplier" in VivadoImpl(BitHeapCompressorUseInversionConfig(infosFromMult).implH, "PostSum")
  //  ignore should "impl for irregular output from a multiplier" in VivadoImpl(BitHeapCompressorUseInversionConfig(infosFromMultWithNoise).implH, "PostSumIrregular")
  //
  //  it should "work for negative operands" in testFuncForInfosOnce(infosWithNegative, UseInversionWithSignFlag)
  //
  //  behavior of "Bit Matrix Compressor on MultiOperandAdder"
  //
  //  it should "work on small rectangular shape situation" in testFuncForInfosOnce(infosSmall)
  //  it should "impl for a small rectangular shape situation" in VivadoImpl(MultiOperandAdderConfig(genRectangularInfos(10, 10)).implH, "SmallTree")
  //
  //  it should "work on simple situation with noise" in testFuncForInfosOnce(infosSmallWithNoise)
  //
  //  it should "work on rectangular shape situation" in testFuncForInfosOnce(genRectangularInfos(40, 40))
  //  it should "work for situation 1" in testFuncForInfosOnce(infosFromMult)
  //  it should "work for situation 2" in testFuncForInfosOnce(infosFromMultWithNoise)
  //
  //  ignore should "impl for rectangular bits" in VivadoImpl(MultiOperandAdderConfig(infosRegular).implH, "RegularSum")
  //  ignore should "impl for output from a multiplier" in VivadoImpl(MultiOperandAdderConfig(infosFromMult).implH, "PostSum")
  //  ignore should "impl for irregular output from a multiplier" in VivadoImpl(MultiOperandAdderConfig(infosFromMultWithNoise).implH, "PostSumIrregular")
  //
  //  it should "work for negative operands" in testFuncForInfosOnce(infosWithNegative)
  //
  behavior of "Bit Matrix Compressor on MultiOperandAdderWithSignFlag"
  //
  //  it should "work on small rectangular shape situation" in testFuncForInfosOnce(infosSmall, MultiOperandWithSignFlag)
  //  it should "impl for a small rectangular shape situation" in VivadoImpl(MultiOperandAdderConfig(genRectangularInfos(10, 10)).implH, "SmallTree")
  //
  //  it should "work on simple situation with noise" in testFuncForInfosOnce(infosSmallWithNoise, MultiOperandWithSignFlag)
  //
  //  it should "work on rectangular shape situation" in testFuncForInfosOnce(genRectangularInfos(40, 40), MultiOperandWithSignFlag)
  //  it should "work for situation 1" in testFuncForInfosOnce(infosFromMult, MultiOperandWithSignFlag)
  //  it should "work for situation 2" in testFuncForInfosOnce(infosFromMultWithNoise, MultiOperandWithSignFlag)

  //  it should "impl for infosFromMultWithTimes" in VivadoImpl(MultiOperandAdderWithSignFlagConfig(infosFromMultWithTimes).implH, "infosFromMultWithTimes")
  //
  //  ignore should "impl for rectangular bits" in VivadoImpl(MultiOperandAdderConfig(infosRegular).implH, "RegularSum")
  //  ignore should "impl for output from a multiplier" in VivadoImpl(MultiOperandAdderConfig(infosFromMult).implH, "PostSum")
  //  ignore should "impl for irregular output from a multiplier" in VivadoImpl(MultiOperandAdderConfig(infosFromMultWithNoise).implH, "PostSumIrregular")
  //
  //  it should "work for negative operands" in testFuncForInfosOnce(infosWithNegative, MultiOperandWithSignFlag)


  val infosFromMultWithNoises = Range.inclusive(1, 41, 2).flatMap { i =>
    Range.inclusive(2, 6, 2).map { j =>
      genTriangleInfos(width = if ((680 / i) % 2 == 0) i * (680 / i + 1) else i * (680 / i + 2), stairShape = (i, j), withNoise = true, timeStrategy = NoneStrategy, upBound = 10)
    }
  }
  val infosFromMults = Range.inclusive(1, 41, 2).flatMap { i =>
    Range.inclusive(2, 6, 2).map { j =>
      genTriangleInfos(width = if ((680 / i) % 2 == 0) i * (680 / i + 1) else i * (680 / i + 2), stairShape = (i, j))
    }
  }
  var t = -1
  val infosFromMultWithTimes = Range.inclusive(1, 5, 2).flatMap { i =>
    Range.inclusive(2, 6, 2).map { j =>
      genTriangleInfos(width = if ((120 / i) % 2 == 0) i * (120 / i + 1) else i * (120 / i + 2), stairShape = (i, j), withNoise = true, timeStrategy = NoneStrategy, upBound = 10)
    }
  }.flatMap { infos =>
    t += 1
    infos.map(info => ArithInfo(info.width, info.weight, info.isPositive, t))
  }

  infosFromMults.foreach(testcase =>
    it should s"work for situation ${infosFromMults.indexOf(testcase)} in infosFromMults" in testFuncForInfosOnce(testcase, MultiOperandWithSignFlag)
  )
  infosFromMultWithNoises.foreach(testcase =>
    it should s"work for situation ${infosFromMultWithNoises.indexOf(testcase)} in infosFromMultWithNoises" in testFuncForInfosOnce(testcase, MultiOperandWithSignFlag)
  )
  //  ignore should s"work for situation in infosFromMultWithTimes" in testFuncForInfosOnce(infosFromMultWithTimes, MultiOperandWithSignFlag)

  val infosRegulars = Range.inclusive(100, 700, 50).map(s => genRectangularInfos(width = s, height = s))

  val infosRegularWithNoises = Range.inclusive(100, 700, 50).map(s => genRectangularInfos(width = s, height = s, withNoise = true))

  infosRegulars.foreach(testcase =>
    it should s"work for situation ${infosRegulars.indexOf(testcase)} in infosRegulars" in testFuncForInfosOnce(testcase, MultiOperandWithSignFlag)
  )
  infosRegularWithNoises.foreach(testcase =>
    it should s"work for situation ${infosRegularWithNoises.indexOf(testcase)} in infosRegularWithNoises" in testFuncForInfosOnce(testcase, MultiOperandWithSignFlag)
  )


}
